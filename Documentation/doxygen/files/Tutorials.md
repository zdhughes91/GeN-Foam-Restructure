# Tutorials {#TUTORIALS}

Several tutorials have been prepared to help users familiarize with GeN-Foam and provide a relatively comprehensive outlook of its functionalities. In each tutorial:
* a README file provides a general description of the tutorials.
* the relevant entries in the input files (dictionaries) are often commented to allow identifying the role of non-obvious parameters.
* an Allrun bash script is provided that can be used to run the tutorial. The  Allrun script can also give a better understanding of the steps to take to run GeN-Foam simulations.
* in computational intensive cases, an Allrun_parallel bash script is provided to run the tutorial using multiple cores.
* an Allclean script is provided to clean up a case after running it.

The following tutorials are distributed together with GeN-Foam. The list below is in alphabetic order and do not represent a progression in complexity. However, **in 3D_SmallESFR, (hopefully) all non-obvious or non-OpenFOAM-standard input parameters are commented, or they include an indication about the tutorial to look at for additional information**. It represents a good starting point to understand and use GeN-Foam, at least for single-phase applications.

* *1D_HX* showcases the utilization of the heatExchanger feature. This feature allows to thermally couple two mesh domains that exists within the same mesh region, but whose cells are otherwise not connected one another. In particular, the test case consists of two parallel 1-D channels, both with their inlet and outlet. Axially, a heated cellZone exists only on one of the two channels, while two cellZones acting as a primary and secondary side of a heat exchanger, respectively, exist on each channel, allowing the heated fluid in the heated channel to exchange heat with the cooler fluid flow in the unheated channel. The onePhase case showcases the feature for a single phase flow, while the twoPhase case showcases the feature for two-phase flow, in which the vapour condenses in the heatExchanger cellZone and heats up the fluid on the other heatExchanger side. FunctionObjects (defined at the end of the controlDict for both cases) allow to track quantities of interest at the end of each time-step, such as the liquid inlet and outlet temperature and mass flow on both channels, allowing to check for energy conservation. The specfic heatExchanger feature options related to its usage are commented in the constant/fluidRegion/phaseProperties dictionary of each case.

* *1D_boiling* illustrates in a simple way the two-phase capabilities of GeN-Foam. It consists of a 1D channel with pressure-driven sodium flow. A power source is turned on at time 0 and eventually leads to boiling, with flow excursion (as the flow is pressure driven). When the maximum  void fraction passes a certain threshold, the power source is turned off (see controlDict). This situation is typically encountered in sodium boiling experiments (e.g. KNS). The plot.py script allows you to plot the initial residual of the pressure equation (the most critical to the solver) at the BEGINNING of the LAST Outer iteration. This gives a measure of how well the COUPLING between energy and fluid dynamics has converged. This is different than the LAST initialResidual of the LAST Outer iteration (which will always be
significantly smaller). For further info see comments in constant/fluidRegion/phaseProperties, system/controlDict, system/fluidRegion/fvSolution. 

* *1D_MSR_pointKinetics* displays how to use the point kinetics module of GeN-Foam for MSRs. It is a simple 1-D case with core, hot leg, pump, heat exchanger and cold leg. The geometry is one dimensional and salt recirculation is simulated by making use of a cyclic boundary condition between top and bottom boundaries. Three simulations are performed: a first simulation couples energy and fluid dynamics to obtain a steady state at the desired power level; a second simulation couples energy, fluid dynamics and point kinetics to simulate a loss-of-flow; a third simulation is run to allow GeN-Foam to recalculate the reactivity  loss due to recirculation of the delayed neutron precursors (which can be used to verify the results vs analystical results). Please notice that the power for the steady state has been imposed via the powerDensity field specified in the fluidProperties sub-dictionary in the constant/fluidRegion/phaseProperties dictionary and models a constant power density in the core and null in the other regions. This power is then automatically updated by the point kinetics solver during the transient. Please notice also that a correct evaluation of the reactivity worth of delayed neutron precursors in MSRs would require knowledge of the adjointflux. In GeN-Foam, the adjoint flux is approximated by the oneGroupFlux.When fluxes are not calculated via a diffusion calculation, one has to manually provide the oneGroupFlux in 0/neutroRegion. In this tutorial, the oneGroupFlux has been set to 1 in the core and zero elsewhere. This is done via the initialOneGroupFluxByZone keyword in nuclearData. A few python files are provided to plot essential results (for instance:
 python plotPKPower_Temp.py ./transient/log.GeN-Foam ). In addition, a .m file (that can be run using Octave)is provided that calculates expected results at the end of the transient.

* *1D_thermalMSR_pointKinetics*  is the same as 1D_MSR_pointKinetics, but for a thermal MSR. This implies that there is
a graphite structure in the core. The objective is to show: how to use the lumpedParamterStructure power model; and how to set a power density both in the salt and in the graphite.

* *1D_PSBT_SC* presents a simple 1-D case for water boiling based on the OECD/NEA Benchmark Based on NUPEC Pressurised Water Reactor (PWR) Subchannel and Bundle Tests (PSBT), case 12223 (excecise 1). Please note that models for water boiling are still preliminary, incomplete (missing models for boiling crisis) and in Beta testing.

* *1D_CHF* provides 2 examples of of 1-D channels with boiling water and achievement of critical heat flux conditions, both in the case of imposed power and in the case of imposed temperature. In the case with imposed power, the power is gradually increased and subsequently decreased in order to reproduce the well-known histeresis caused by the boiling crisis. In the case with imposed temperature, the temperature is only increased with time. It shows that with imposed temperature we pass through the Leidenfrost temperature. The resulting heat flux vs wall temperature curves can be plotted using python3 and the printResults.py scripts that are available in each case folder.

* *2D_cavityBoussinesq* portrays the use of the Boussinesq feature. The Boussinesq approximation is used in buoyancy driven flows and assumes that the effects of temperature-induced density changes are relevant ONLY in the calculation of the buoyancy momentum source terms, while in all other terms of the momentum equation the density is kept constant. The domain consists of a square with 10 cm sides and two opposing walls maintained at 500 K and 1000 K, with the fluid starting at rest and at 500 K. The cooled and heated wall patch normal are perpendicular to gravity, while gravity acts in the positive X direction.  A steady state is reached with the establishment of a circular liquid motion so that it rises against gravity at the heated wall and descends at the cooled wall.

* *2D_FFTF* is a model of the Fast Flux Test Facility. It was in a hybrid pool-loop configurations, where the the primary pumops and IHXs lie in a loop outside the vessel. This case reproduces the LOFWOS 13 Test performed at the FFTF in order to test the effectiveness of the Gas Expansion Module (GEM) safety feature. In essence, these were empty assembly wrappers closed at the top and open at the bottom, partly filled with argon gas, positioned at the periphery of the active core. In operation, the pressure head at the GEM inlet would compress the argon gas so that the free surface sodium level would rise above the active core level. During a ULOF, the loss of pressure head would cause the argon gas to expand and lower the free surface sodium level below the active core region, thus increasing leakage. The model is hydrid as the vessel consists of a 2-degree wedge while the loops consist of parallelepipeds. All the volumes are scaled by a factor 360/2. From a calculation perspective, the steady-state is run for 900 s, followed by a transient case in which a pointKinetics model is used to model the power evolution. Please notice that the power for the steady state is set directly via the field powerDensity.nuclearFuelPin in 0/fluidRegion, though the Allrun_powerFromDiffusion script is also provided that instead runs an initial diffusion calculation and uses the resulting power profile in the subsequent transient. For convenience, the transient simulation ends at 1200 s, as most of the dynamics is resolved at that point  From a user perspective, this case showcases the usage of the gapHPowerDensityTable and a time-dependent momentumSource, as discussed in constant/fluidRegion/phaseProperties. A third feature is the GEM, which are currently partially hard coded in the pointKinetics class. The case showcases the use of the decay power model for point kinetics (not implemented for liquidFuel yet, though). In constant/neutroRegion/reactorState one can optionally define a decay power and its evolution in time (via a table or expressions evaulated via the standard OpenFOAM Function1 feature). The power provided under pTarget is the initial TOTAL power, and the pointKinetics model will operate only on the fission power, initially set as total minus decay. The heatExchanger feature is used to model heat transfer between the two physically separated mesh-domains representing the primary and the secondary loops. Furthermore, the model uses the momentumMode named cellCenteredFaceReconstruction. 

* *2D_MSFR* is a 2-D r-z model of a Molten Salt Fast Reactor. It solves for neutronics and thermal-hydraulics. The Allrun bash  script will first run a steady-state case with fluid-dynamics only. Starting from the results of the simulation, a second steady-state is launched solving for neutronics and energy equations. Finally, a simple transient calculation is run. No reactivity is inserted in the transient and the power will simply stay constant for 10 seconds. Any modification to the initial conditions of the transient case will instead trigger an actual transient. For example, modifying the *keff* in the *reactorState* dictionary will trigger a reactivity-initiated transient. A more realistic transient can be initiated by modifying the heat transfer in the heat exchanger in the *phaseProperties* dict. The case is similar to the one presented in Ref. \cite refId0 . Please note that, to reduce computing time, the fluid-dynamics equations are not solved in the second steady-state and in the transient simulation. Note also that an upwind scheme is employed for the divergence term in the diffusion equations (in *system/neutroRegion/fvSchemes*), which is necessary to achieve convergence. 

* *2D_onePhaseAndPointKineticsCoupling* is a simplified test-case for the *pointKinetics* neutronics model. It consists of a 2-D square domain made of a single porous cellZone containing fuel as sub-scale structure. A coolant (properties ~ sodium) flows from the bottom of the domain to the top. A set of cross-sections has been arbitrarily chosen and is used in the steady-state calculation to obtain (using the diffusion solver) a flux (and power) shape to be used in the point kinetic calculations. Without this step, the point kinetic solvers would assume a flat power profile.  Three transients are simulated: a 0.2$ reactivity insertion with the only feedback being a -0.3 pcm/K for fuel temperature (arbitrary); a 0.2$ reactivity insertion with an additional feedback from an assumed driveline expansion; like the first transient, but with time dependent insertion of reactivity from Boron (removal), with a reactivity profile that is specified in nuclearData. In the second transient, the control rod reactivity map (see *constant/neutroRegion/nuclearData*) is set to 100pcm/cm (more than one order of magnitude higher than realistic values, used here only for demonstration purposes). The absolute driveline thermal expansion coefficient is assumed to be 8e-5 m/K. Time steps are adjusted to resolve 1% power increases (see *system/controlDict*). Results (power and average fuel temperature) can be visualized via the plot.py python script. To run, use the Allrun bash script. Several additional information on the tutorial and on the point kinetic model can be found in the README file of the tutorial. In addition, a detailed explanation of the parameters employed for point kinetics calculations can be found in *constant/neutroRegion/nuclearData*.

*  *2D_voidMotionNoPhaseChange* is a very simple tutorial displaying a two-phase case without mass transfer between phases. Please refer to the 1D_boiling tutorial for details on how to use  the two=phase flow solver. The main additional feature employed in this tutorial compared to *1D_boiling* is the use of the *initialAlphas* subdict in the *vapourProperties* subdict of the *phaseProperties* dictionary. It is used to provide potentially different initital phase fractions for different cellZones (as an alternative to the use of setFields).To run, use the Allrun bash script. 

* *3D_SmallESFR* is a slightly simplified 3-D model of the core of the European Sodium Fast Reactor (ESFR). It is a full multiphysics case, including thermal-hydraulics, neutronics and thermal-mechanics (with expansion of the meshes based on the displacement field calculated by the thermal-mechanics). The Allrun and Allrun_parallel bash scripts can be used to run the tutorial in 1 or 4 cores, respectively. The scripts will first run a steady-state case with eigenvalue neutronics, and then start from the obtained steady-state and run a simple transient calculation. No reactivity is inserted in the transient and the power will simply stay constant for 10 seconds. Any modification to the initial conditions of the transient case will instead trigger an actual transient. For example, modifying the *keff* in the *reactorState* dictionary will trigger a reactivity-initiated transient. A more realistic transient can be initiated by modifying the *CRmove* dictionary. The case is similar to the one presented in Refs. \cite FIORINA201524 \cite Fiorina2015ApplicationCodes.

* *godiva_SN* This is a purely neutronic eigenvalue case displaying how to use the discrete ordinate (SN) solver of GeN-Foam. It simulates the Godiva experiment, constituted by a small super-prompt-critical sphere of enriched uranium. The SN solver is selected in the *constant/neutroRegion/neutronicProperties* dictionary. The file *constant/neutroRegion/quadratureSet* contains a simple quadrature set with 4 direction per octant. A more complex  (and more computationally requiring) quadrature set with 16 directions per octant can be found in *constant/neutroRegion/quadratureSet16*. A simpler one, with 1 direction per octant, can be found in *constant/neutroRegion/quadratureSet16*. The scattering anistotropy can be changed by changing the *legendreMoments* flag in *constant/neutroRegion/nuclearData*. Of course one should make sure that the corresponding scattering matrices are provided in the same file. In the current tutorial, scattering matrix are provided till the 5th moment. This is a  computationally intensive tutorial. It is suggested to run it using the Allrun_parallel bash script on a good machine. In principle, the SN solver could be used for time-dependent calculations. However, no acceleration techniques are currently implemented, making the solver particularly slow. An Allclean script is provided to clean up the case.

**Work in progress / need adaptation from previous GeN-Foam**
* ESFR2D_regression is a 2-D r-z model of the ESFR. It is a full multiphysics case. It includes both core and primary pool. The pyhton Allrun.py and the bash Allrun.sh scripts sequentially run  a number of cases as specified in the runDict file. The current set-up perform a full set of cases with increasing complexity and it is suitable as regression case. Additional information in the regression case can be found in Ref. [4].